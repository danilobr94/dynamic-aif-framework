"""Visualize long term effect of a classifier.

Steps:
    1. Make predictions using decision function on ltf_data set
    2. Evaluate accuracy and fairness ltf_aif on predictions
    3. Sample next generation using sampling function
    4. Repeat step 1

    TODO: pass initial ltf_data set?
    TODO: add a separate baseline_clf?
"""


import matplotlib.pyplot as plt
import numpy as np
from .time_step_plot import GenerationPlot


class LongTermFairnessPlot:
    """"""

    def __init__(self, data_generator, clf, fairness_metric, update_clf=False, x_lim=None, y_lim=None):
        """

        :param data_generator: (object) must implement sample(X, y, y_hat) and get_label(X) functions
        :param clf: (object) must implement fit(X, X_s, y) and predict(X, X_s) functions
        :param fairness_metric: (function) X, X_s, y, y_hat
        :param update_clf: (bool)
        """
        self._data_generator = data_generator
        self._clf = clf
        self._fairness_metric = fairness_metric

        self._update_clf = update_clf

        self._X_sensitive = []
        self._X_sensitive_baseline = []

        self._results = []
        self._X = []
        self._y = []
        self._y_hat = []

        self._baseline_results = []
        self._X_baseline = []
        self._y_baseline = []
        self._y_hat_baseline = []

        self._pos_label = 1
        self._neg_label = 0

        self._pos_class = 1
        self._neg_class = 0

        self._x_lim = x_lim
        self._y_lim = y_lim

        self._data_generating_decision_boundary = None
        self._clf_decision_boundary = None

        self._time_step_plot = GenerationPlot(self._x_lim,
                                              self._y_lim,
                                              self._pos_label, self._neg_label,
                                              self._pos_class, self._neg_class)

    def export_data(self):
        """"""
        raise NotImplemented

    def run(self, num_steps):
        """"""
        self.init_data()

        for _i in range(num_steps):
            self.run_generation()
            self.run_baseline_generation()

    def init_data(self):
        """"""
        X_init, X_sens_init, y_init = self._data_generator.sample(None, None, None)

        self._X_sensitive.append(X_sens_init)
        self._X_sensitive_baseline.append(X_sens_init)

        self._X.append(X_init)
        self._y.append(y_init)

        self._fit_clf()
        y_hat_init = self._clf.predict(X_init, X_sens_init)

        self._y_hat.append(y_hat_init)

        self._X_baseline.append(X_init)
        self._y_baseline.append(y_init)
        self._y_hat_baseline.append(y_hat_init)

    def run_generation(self):
        """"""
        X_t, X_sens_t, y_t = self._data_generator.sample(self._X,
                                                         self._y,
                                                         self._y_hat)

        y_hat_t = self._clf.predict(X_t, X_sens_t)

        metric = self._fairness_metric(X_t, X_sens_t, y_t, y_hat_t)

        self._X.append(X_t)
        self._X_sensitive.append(X_sens_t)
        self._y.append(y_t)
        self._y_hat.append(y_hat_t)

        if self._update_clf:
            self._fit_clf()

        self._results.append(metric)

        return metric

    def run_baseline_generation(self):
        """Baseline ltf_data and predictions.

        The baseline ltf_data is generated by passing only positive predictions
        """
        y_hat_pos = np.ones(np.shape(self._y_hat_baseline)) * self._pos_label

        X_t_base, X_sens_t_base, y_t_base = self._data_generator.sample(self._X_baseline,
                                                                        self._y_baseline,
                                                                        y_hat_pos)

        y_hat_t_base = self._clf.predict(X_t_base, X_sens_t_base)

        metric = self._fairness_metric(X_t_base, X_sens_t_base, y_t_base, y_hat_t_base)

        self._X_baseline.append(X_t_base)
        self._X_sensitive_baseline.append(X_sens_t_base)
        self._y_baseline.append(y_t_base)
        self._y_hat_baseline.append(y_hat_t_base)

        self._baseline_results.append(metric)

        return metric

    def plot_ltf(self, labels=""):
        """Plots the results over all generations"""
        result_arr = np.asarray(self._results)
        baseline_result_arr = np.asarray(self._baseline_results)
        num_generations, num_metrics = result_arr.shape

        for i in range(num_metrics):
            lbl = "ltf_aif " + str(i) if labels == "" else labels[i]
            plt.plot(range(num_generations), result_arr[:, i], label=lbl)
            plt.plot(range(num_generations),
                     baseline_result_arr[:, i],
                     label="baseline " + lbl,
                     linestyle="--")

        plt.xlabel("Generation")
        plt.legend()
        plt.show()

    def plot_generation(self, plot_decision_boundary=True):
        """Plot """
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))

        # maybe add decision boundary
        if plot_decision_boundary:
            if self._data_generating_decision_boundary is None:
                self._data_generating_decision_boundary = \
                    self._time_step_plot.get_decision_boundary(self._X[-1],
                                                               self._data_generator.get_label)

            if self._clf_decision_boundary is None or self._update_clf:
                self._clf_decision_boundary = self._time_step_plot.get_decision_boundary(self._X[-1],
                                                                                         self._clf.predict)

            self._time_step_plot.add_decision_boundary(ax1, self._clf_decision_boundary, label="clf boundary")
            self._time_step_plot.add_decision_boundary(ax2, self._clf_decision_boundary, label="clf boundary")

            self._time_step_plot.add_decision_boundary(ax1, self._data_generating_decision_boundary, cmap="Pastel1")
            self._time_step_plot.add_decision_boundary(ax2, self._data_generating_decision_boundary, cmap="Pastel1")

        # scatter the points
        self._time_step_plot.scatter_data_points(ax1,
                                                 self._X[-1],
                                                 self._y_hat[-1],
                                                 self._X_sensitive[-1],
                                                 "true ltf_data")

        self._time_step_plot.scatter_data_points(ax2,
                                                 self._X_baseline[-1],
                                                 self._y_hat_baseline[-1],
                                                 self._X_sensitive_baseline[-1],
                                                 "baseline ltf_data")

        fig.suptitle("Generation " + str(len(self._y_hat)-1))

        ax1.legend()
        ax2.legend()

        plt.show()

    def _fit_clf(self):
        """"""
        X = np.vstack(self._X).squeeze()
        y = np.hstack(self._y).squeeze()

        num_repetitions = np.shape(self._X)[0]
        X_s = np.repeat(self._X_sensitive, num_repetitions)

        print("updated clf")
        self._clf.fit(X, X_s, y)




